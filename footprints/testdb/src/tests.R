# define path to sample data on Whovian - this data can be generated by 
# running 'make wellington' with this code: 
# https://github.com/PriceLab/BDDS/tree/master/footprints/functionalTests

# here's the path on whovian
# wellington.path <- "/local/Ben/BDDS/footprints/functionalTests/output/wellington"

# and here's the path on galaxy
wellington.path <- "/scratch/galaxy/test/BDDS/footprints/functionalTests/output/wellington"

test.sampleID <- "ENCSR000DBY"

#-------------------------------------------------------------------------------
runTests <- function()
{
  # add knownLocs global environment
  knownLocs <<- new.env(parent=emptyenv())
  
  # run the tests
  test.getDBConnection()
  test.readWellingtonTable()
  test.mergeFootprintsWithFimo()
  test.splitTableIntoRegionsAndWellingtonHits()
  test.fillToDatabase()
} #runTests
#-------------------------------------------------------------------------------
test.getDBConnection <- function()
{
  printf("--- test.getDBConnection")
  
  db.testConnection <- getDBConnection("trenatest")
  
  # test the class of db.testConnection
  checkEquals(class(db.testConnection)[1], "PostgreSQLConnection")
  
  # test that we can read tables from db.testConnection
  checkEquals(dbExistsTable(db.testConnection, "testtable"), TRUE)
  
  # test that we can write to db.testConnection
  checkEquals(
    dbWriteTable(conn = db.testConnection,
                 name = "testtable",
                 value=data.frame("teststring"), 
                 append = TRUE, 
                 row.names = FALSE),
    TRUE)
  
  # test that we can read from db.testConnection
  checkEquals(
    is.data.frame(
      dbGetQuery(db.testConnection, "select * from testtable")
    ), TRUE)
  
  # clean up and disconnect
  dbGetQuery(db.testConnection, "DELETE FROM testtable")
  dbDisconnect(db.testConnection)
} # test.getDBConnection
#-------------------------------------------------------------------------------
test.readDataTable <- function()
{
  printf("--- test.readDataTable")
  
  tbl <- readDataTable(wellington.path, test.sampleID, 5, "chr19")
  checkEquals(dim(tbl), c(5,6))
  checkEquals(colnames(tbl), c("chrom", "start", "end", "name", "score", "strand"))
  checkEquals(unique(tbl$chrom), "chr19")
  
  # now read without chrom or nrow constraints
  tbl <- readDataTable(wellington.path, test.sampleID)
  checkEquals(ncol(tbl), 6)
  checkTrue(nrow(tbl) > 300)
  checkEquals(colnames(tbl), c("chrom", "start", "end", "name", "score", "strand"))
  checkEquals(head(sort(unique(tbl$chrom))), "chr19")
  
} # test.readDataTable
#-------------------------------------------------------------------------------
test.mergeFootprintsWithFimo <- function()
{
  printf("--- test.mergeFootprintsWithFimo")
  if(!exists("db.fimo")) {
    db.fimo <- getDBConnection("fimo")
  }
  tbl.fp <- readWellingtonTable(wellington.path, test.sampleID, nrow=3, "chr19")
  tbl <- mergeFimoWithFootprints(tbl.fp, test.sampleID, dbConnection = db.fimo)
  checkEquals(ncol(tbl), 12)
  checkEquals(sort(colnames(tbl)),
              c("chrom", "fimo.pvalue", "fimo.score", "loc", "method",
                "motif", "motif.end", "motif.sequence", "motif.start", 
                "motif.strand", "sample_id", "wellington.score"))
  checkTrue(nrow(tbl) >= 1)
  
  #duplicated.loc <- "chr19:357336-357350"
  #checkEquals(length(grep(duplicated.loc, tbl$loc)), 1)
  #  3 distinct motifs mapped to this region
  #checkEquals(sort(subset(tbl, loc == duplicated.loc)$motif), "MA0697.1")
  
  invisible(tbl)
  
} # test.mergeFootprintsWithFimo
#-------------------------------------------------------------------------------
test.splitTableIntoRegionsAndWellingtonHits <- function(tbl)
{
  printf("--- test.splitTableIntoRegionsAndWellingtonHits")
  if(!exists("db.fimo")) {
    db.fimo <- getDBConnection("fimo")
  }
  tbl.fp <- readWellingtonTable(wellington.path, test.sampleID, nrow=3, "chr19")
  tbl <- mergeFimoWithFootprints(tbl.fp, test.sampleID, dbConnection = db.fimo)
  
  x <- splitTableIntoRegionsAndWellingtonHits(tbl, "minid")
  checkEquals(sort(names(x)), c("hits", "regions"))
  checkEquals(colnames(x$regions), region.schema()) #
  checkEquals(colnames(x$hits), hit.schema())
  
} # test.splitTableIntoRegionsAndWellingtonHits    
#-------------------------------------------------------------------------------
test.fillToDatabase <- function()
{
  printf("--- test.fillToDatabase")
  if(!exists("db.fimo")) {
    db.fimo <- getDBConnection("fimo")
  }
  if(!exists("db.wellington.test"))
    db.wellington.test <- 
      getDBConnection("testwellington")
  
  createEmptyDatabaseTables('ben', 'testwellington', db.wellington.test)
  knownLocs <<- new.env(parent=emptyenv())
  
  tbl.fp <- readWellingtonTable(wellington.path, test.sampleID, nrow=3, "chr19")
  tbl <- mergeFimoWithFootprints(tbl.fp, test.sampleID, dbConnection = db.fimo)
  x <- splitTableIntoRegionsAndWellingtonHits(tbl, "minid")
  
  fillToDatabase(x$regions, x$hits, db.wellington.test, 'ben', 'testwellington')
  checkEquals(sort(dbListTables(db.wellington.test)), c("hits", "regions"))
  
  tbl.regions <- dbGetQuery(db.wellington.test, "select distinct * from regions")
  #checkEquals(dim(tbl.regions), c(4, 4))
  checkTrue(all(region.schema() == colnames(tbl.regions)))
  
  tbl.hits <- dbGetQuery(db.wellington.test, "select distinct * from hits")
  checkTrue(all(hit.schema() == colnames(tbl.hits)))
  #checkEquals(dim(tbl.hits), c(4, 14))
  checkEquals(unique(tbl.hits$type), "motif.in.footprint")
  checkTrue(all(tbl.hits$loc %in% tbl.regions$loc))
  
} # test.fillToDatabase
#-------------------------------------------------------------------------------
